'use strict'
//---------------------------------------------------------------------------------------------------------

// TODO Math
//* Math.ceil - округление вверх, floor - вниз, round - к ближайшему, .toFixed(n) - округление до n знаков после запятой
// TODO Math
//---------------------------------------------------------------------------------------------------------

// TODO Методы консоли (Опционально)
//? console.error('Error') //! Ошибка
//? console.warn('!!!') //! Предупреждение
//? console.table(r) //! таблица
//? console.assert(false, 'Yee') //! по условию выводит
//? console.time(label) console.timeEnd(label) //! Измеряем время выполнения блока скрипта
// TODO Методы консоли (Опционально)

// --------------------------------------------------------------------------------------------------------

// TODO---------------------------------------------Важное-------------------------------------------------
//! У стрелочных функций нет this, arguments, super!!!
//!
// TODO---------------------------------------------Важное-------------------------------------------------

// --------------------------------------------------------------------------------------------------------

// TODO Флаги дискриптора
//!-------------------------------------------------------Флаги--------------------------------------------
//? writable – если true, свойство можно изменить, иначе оно только для чтения.
//? enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
//? configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.
//!------------------------------------------------------Дискрипторы(get/set)------------------------------
//? get() - Геттер (чтение) || set(value) - Сеттер (запись)
//? Object.defineProperty('s)(obj, св-во, {}) - изменить/создать дискриптов у свойства (или всех свойств), при таком создании флаги по умолчанию false
//? Object.getOwnPropertyDescriptor('s)(obj, св-во, {}) - получить дискриптор у свойства или всех свойств

// --------------------------------------------------------------------------------------------------------

// TODO Прототипы
//! [[Prototype]] - скрытое свойство-акссесор ссылающееся на прототип объекта (ссылки не могут быть цикличными)
//! [[Prototype]] - может быть только один, объект не может наследоваться от двух и более объектов
//! __proto__ - геттер и сеттер для [[Prototype]] (либо {объект}, либо null)
//! Если свойства/метода нет, то оно береться из цепочки прототипов, если нет и там = undefined
//! Прототип только для чтения|поиска в нем св-ва/метода, запись|удаление не лезут в прототип. Кроме свойств-акссесоров
//! Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.
//! for in перебирает и унаследованые свойства, obj.hasOwnProperty(key) - возвращает true если в obj есть собственное свойство с именем key
//! new F() - конструктор, Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта. 'prototype' - {объект} или null
//! F.prototype это обычное свойство функции с имененем 'prototype', используется только при вызове new F() для установки прототипа
//! в F.prototype по умолчанию prototype:{constructor: F}
//! prototype есть только у функций
//! Object.create(прототип(объект), дискриптор всех свойств), Object.getPrototypeOf(obj)/Object.setPrototypeOf(obj)
// TODO Прототипы

// --------------------------------------------------------------------------------------------------------

// TODO Классы
//* Методы в классе не разделяются запятой! Class = Function, класс это функция
//* Не может быть вызван без new, в отличии от функции конструктора
//* Все методы записываются в prototype класса и автоматически ставиться флаг enumerable: false (не перечисляются в for in)
//* Код внутри класса всегда в 'use strict'
//* class Chield extends Parent - наследование класса, Chield наследует от Parent (после extends можно указывать не только классы)
//* super.method(..) - вызывает метод родительского класса (можно использовать при переопределении метода), у стрелочных функций нет super
//* Если у класса-потомка нет constructor он берется у родителя родителя
//* Для расширения constructor у потомка нужно до обращения к this, ВСЕГДА вызвать super(...) - вызов констурктора у родителя
//* static - статические методы или сойства класса, class.method(..) (если перед метод static), статические свойства и методы наледуются другим классом
//* extends устанавливает 2 связи. Между Chield.prototype.__proto__ === Parent.prototype - для методов || Chield.__proto__ === Parent - для static
//* # - приватное поля класса, не наследуется другими класами (функция языка)
//* instanceOf() - проверяет на принадлежноть к определеннму классу через прототипную цепоцку
//* Object.prototype.toString(...) - точный класс/тип в формате '[type ....]'    
// TODO Классы

// --------------------------------------------------------------------------------------------------------

// TODO Promise
//? В Promise мы оборачивает какое-то асинхронное действие
//? resolve(value-результат) — если работа кода внутри промиса завершилась успешно, с результатом value || reject(error-объект ошибки) — если произошла ошибка, error – объект ошибки.
//? Функция переданя в промис запускается автоматически и должна по завершению вызвать resolve или reject, ОБЯЗАТЕЛЬНО!
//? Внутриние св-ва объекта возвращаемого промисом: [[State]](состояние) - pending(ожидание), fulfilled(при resolve), rejected(при reject)
//? [[Result]](результат) - undefined(в начале), value(при resolve), error(при reject), value и error автоматически передается в then|cath
//? Обработчики: .then(f(value),f(error)) -> f1-при resolve || f2-при reject, указывать можно обе или одну, альтернатива .cath - .then(null, f)
//? .cath(f(error)) -> f-только при reject || .finaly(f) - выполнится в независимости resolve или reject, f - без аргументов, пропускает дальше err/value
//? Обработчики всегда ждут завершения Promise и выполняются после, можно вызвать сколько угодно раз.
//? .then - возвращает промис, .then().then()... - цепочка вызовов, then оборачивает результат в callback
//? .cath лучше добавлять в самом конце цепочки промисов, т.к когда выдается исключение(ошибка), то код падает и идет к ближайшей catch как и в try...catch, также работает проброс ошибок и throw
//? Без проброса, код пойдет к ближайшему обработчику после catch
//! unhandledrejection(событие) - обработчик ошибок в браузере, если нет catch или нет способа обработать ошибку
//? Обработчики всегда асинхронны (как и Eventloop)
//*---------------------------------------------------------Promise API------------------------------------(Опционально)
//! Promise.all([массив промисов]) возвращает массив результатов, если ошибка хотя бы в 1 результат игнорируется
//? Promise.allSettled([массив]) возварщает [{status: fulfiled, value: рузультат} - для выполненых,{status: rejected, reason: объект ошибки}-для ошибок]
//! Promise.race([]) - ждет самый быстрый выполненый промис и берет из него ответ или ошибку, результат value/err
//? Promise.resolve(value) - возвращает промис(resolve) с value, Рromise.reject(error) - возвращает промис(reject) с error || Используются для поддержки
//*---------------------------------------------------------Promise API------------------------------------(Опционально)
//? async - заставляет возвращать промис в функции или обернуть в промис результат функции
//? await - перед promise заставляет JS движек ждать его выполнения, только внутри async, возвращает результат (не только промис) или объект ошибки, ошибки ловим try...catch или внешним .catch
//? const ... = async () => ... - для стрелочных функций, async method(){...} - для методов объекта
// TODO Promise

//TODO Fetch 
//! fetch(url, {options}) - API для async запросов, url - string, по умолчанию метод GET
//! Возвращает Promise, объект с параметрами .ok - true/false, status - HTTP code, .headers - заголовки ответа  
//! Для отмены запроса - class AbortController, инстансом является объект {} с методом abort() и свойством signal
//! При вызове abort() на объекте signal генерируется событие 'abort' и signal.aborted становится равным true
//! Что бы узнать об вызове abort() нужно слушать событие 'abort' на объекте signal 
//! Для использования в параметры запроса fetch в поле signal: передаем свойство signal 
//TODO Fetch 

//TODO Перебираемые объекты 
//* для реализации беребираемого объекта (в цикле for of), нужно добавить метод с имененм Symbol.iterator
//* он должен возвращать объект итератора в котором должен быть оперделен метод next() - он будет вызываться на наждой новой итерации
//* в качестве итераторов можно использовать генераторы т.к их принцип работы очень похож
//* Псевдомассивы - объекты имеющие индексы и свойство lenght, Перебираемые объекты - объекты реализующие метод Symbol.iterator 
//TODO Перебираемые объекты 

//TODO Преобразование объектов в примитивы 
//? универсальным способом является добавления метода с именем [Symbol.toPrimitive], который будет принимать hint - это тип преобразования 'string'/'number'/'default' и в зависимости от него возвращать какое-лиюо значение
//? Если нет метода Symbol.toPrimitive то движек JS пытается вызвать следующие методы, для hint='string' -> toString() -> valueOf(), и valueOf() -> toString() - в случает 'number' и 'default'
//? Если при любом преобразовании возвращать одно и тоже, то можно определить только метот toString()
//! Правило - все методы должны возвращать примитив а не объект! 
//TODO Преобразование объектов в примитивы 

// --------------------------------------------------------------------------------------------------------

//TODO Модули (статика) (всегда use strict, нет внешнего this = undefined, свой scope, не работает в {...} - блочной области видимости)
//* import {...} from 'путь..' || export (в script type = 'module', по умолчанию у модулей defer)
//* import * as ... from 'путь..' - импортирует все export как объект (без скобок)
//* import {... as ...}, export {... as ...} - заменить имя переменной (либо там лиюо там)
//* export default (может быть только один, по умлочанию), import ... from 'путь...' - без скобок
//* export {... as default}, import {default as ..., ...} - default и именованный export
//* export {...} from ... - реекспорт (импорт из from и сразу export)
//TODO Модули (динамика)
// * ...

// --------------------------------------------------------------------------------------------------------

// TODO Разное
//* ------------------------------------ Proxy -------------------------------------------------

//* ------------------------------------ Eval --------------------------------------------------
//! eval('...') - выполняет строку кода указанную внутри
//! eval доступны внешние лексические переменные, он может менять их или использовать, т.к выполняется в текущем лексическом окружении
//! в use strict у eval свое лексическое окружение, все что внутри не видно, без видно
//! window.eval - выполнится в глобальном окружении
//* ------------------------------------ BigInt --------------------------------------------------
//! 9007199254740991 - максимальное число в JS
//! Что бы получить bigint нужно вызвать BigInt() или добавить 'n' в конце, произвольно длинное число
//! Bigint могут быть только целые числа(при необходимости происходит округление в большую сторону), нельзя мешать с обычными числами
//! C bigint работает унарный +, математические операторы работают так же
//* ------------------------------------ Intl (неполная) ----------------------------------------------------
//! Интернационализация - адаптация продукта для использования в любом месте
//! Intl.Collator(local, option) - .compare(), умеет правильно сравнивать и сортировать строки. options - {sensitivity: "accent"} - уберет чувствительность к регистру
//! Intl.DateTimeFormat(local, option) - .format(), умеет форматировать дату и время в соответствии с нужным языком.
//! Intl.NumberFormat(local, option) - .format(), умеет форматировать числа в соответствии с нужным языком.
//! local - локаль, "код языка-код способа записи-код страны", option - объект с параметрами

//* ------------------------------------ Генераторы --------------------------------------------
//! синтаксис function*/ function *name() - ключевое слово function и на конце *
//! функция-генератор возвращает специальный итерируемый объект {[Generator]} 
//! внутри тела функции с помощью ключевого слова yield можно преостанавливать выполнение
//! что бы выполнить действие у возвращаемого объекта есть метот .next() - который вернет объект типа {value: [значение], done: false/true(true когда выполнелось последнее действие)}
//! объект {[Genetaror]}  перебирается в цикле for of где на каждой итерации возвращает value (вычесленное после yield), но не после return
//! Генераторы можно использовать в [Simbol.Inerator] для создания перебираемых объектов
//! yield* generator() - так можно встраивать одни генераторы в другие  
//! первый вызов next() запускает генератор, в последующие вызова мы можем передавать данные внутрь генератора, next(data), тем самым если в теле функции let value = yield, то это переменой присвоиться переданое значение. Таким образом мы можем обмениться данными с функцией по мере ее выолнения
//! для вызова ошибок есть метот .throw(err), она вызовет ошибки там где остановилось выполнение, обрабатывается и выпадает как и обычные ошибки 
//! что бы работать с асинхронностью внутри генераторов перед функцией-генератором async внутри уже можно использовать await, для перебора используется цикл for await(let i of {[Generator]}). Так же .next() возвращает Promise и перед ним тоже нужно await next() 
// TODO Разное


// --------------------------------------------------------------------------------------------------------

//TODO ----------------------------------------------- Браузер --------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------

//TODO DOM
//* document - точка входа в DOM, document.documentElement = <html>, document.body = <body>, document.head = <head>
//* если script в head то body может быть null - в DOM значит "не существует"
//* Дочерние узлы (дети) - элементы которые непосредственно лежат внутри данного тэга, свойство - children, firstElementChild и lastElementChild - первый и последний дочерний элемент
//* Потомки - все элементы которые лежат внутри данного тэга, включая детей и их детей и т.д
//* childNodes и большенство коллекций DOM - это псевдомассив/перебираемый объект и они только для чтения
//* NodeList - коллекция узлов DOM возвращаемая методами, бывает статическая и динамическая
//TODO DOM

// --------------------------------------------------------------------------------------------------------

//TODO Методы поиска элементов по DOM
//? .getElementById(id) - возвращает ссылку на данный тэг(объект) в DOM по указанному id
//? .querySelectorAll(css.selector) - вернет NodeList всего найденного
//? .querySelector(css-selector(class)) - верент первый элемент по данному селекторы
//TODO Методы поиска элементов по DOM

// --------------------------------------------------------------------------------------------------------

//TODO Совйства DOM элементов
//! innerHTML - вернет все HTML-соержимое в виде строки, можно использовать для замены содержимого
//! outerHTML - вернет тоже самое что и innerHTML + сам элемент, не использовать для замены содержимого
//! data - верент содержимое текстового узла
//! textContent - вернет текст внутри элемента без тэгов
//! className - вернет класс элемента, можно использовать для замены
//! Большинство HTML атрибутов присутствуют как свойства объекта этого DOM узла с доступом к ним
//! Есть еще такие свойства как value, href, type и т.д
//TODO Совйства DOM элементов

// --------------------------------------------------------------------------------------------------------

//TODO Работа с атрибутами
//* elem.hasAttribute(name) – проверить на наличие.
//* elem.getAttribute(name) – получить значение.
//* elem.setAttribute(name, value) – установить значение.
//* elem.removeAttribute(name) – удалить атрибут.
//* elem.attributes – это коллекция всех атрибутов.
//* elem.dataset.'часть трибута после data-' - вернет значение этого атрибута
//TODO Работа с атрибутами

// --------------------------------------------------------------------------------------------------------

//TODO Изменения документа
//? document.createElement('tag') - создание элемента с заданным тэгом
//? document.createTextNode(text) - cоздаёт новый текстовый узел с заданным текстом
//? elem.insertAdjacentHTML(where, html) - вставка HTML строки:
//? "beforebegin" – перед elem
//? "afterbegin" в начало elem
//? "beforeend" – в конец elem
//? "afterend" – после elem.
//? node.append(...nodes or strings) – добавляет узлы или строки в конец node,
//? node.prepend(...nodes or strings) – вставляет узлы или строки в начало node,
//? node.before(...nodes or strings) – вставляет узлы или строки до node,
//? node.after(...nodes or strings) – вставляет узлы или строки после node,
//? node.replaceWith(...nodes or strings) – заменяет node заданными узлами или строками.
//? remove(..) - удаление узла
//? cloneNode(true/false) - true-клубокий клон, false - нет
//? .children - вернет дочерние узлы(только тэги)
//TODO Изменения документа

// --------------------------------------------------------------------------------------------------------

//TODO Взаимодействие с классами и стилями
//! .className - весь класс, при замене меняется вся строчка класса
//! .classList - выбирает 1 вариант класса а не всю строчку, являелся перебираемым(for of)
//! elem.classList.add/remove("class") – добавить/удалить класс.
//! elem.classList.toggle("class") – добавить класс, если его нет, иначе удалить.
//! elem.classList.contains("class") – проверка наличия класса, возвращает true/false.
//! для удаления css свойста присваиваем ''
//! для задания сразу множества стилей используется style.cssText = ``
//! getComputedStyle(elem, pseudo) - получить объект стилей элемента
//TODO Взаимодействие с классами и стилями

// --------------------------------------------------------------------------------------------------------

//TODO Размеры и прокрутка элементов
//* offsetParent – ближайший внешний блок, относительно него идут внешние метрики
//* offsetLeft/offsetTop – расстояние от верхнего левого угла offsetParent
//* offsetWidth/offsetHeight – «внешняя» ширина/высота элемента, включая рамки и внутренние отступы (padding) и полосу прокрутки
//* clientLeft/clientTop – отступы внутренней части от внешней (ширина рамки и scrollbar)
//* Для операционных систем с ориентацией слева-направо эти свойства равны ширинам левой/верхней рамки.
//* Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится не справа, а слева, то clientLeft включает в своё значение её ширину.
//* clientWidth/clientHeight – ширина/высота содержимого вместе с внутренними отступами padding, но без полосы прокрутки и рамок
//* scrollWidth/scrollHeight – ширины/высота содержимого, аналогично clientWidth/Height, но учитывают прокрученную и не прокрученную, невидимую область элемента.
//* scrollLeft/scrollTop – ширина/высота прокрученной сверху части элемента, считается от верхнего левого угла, их можно менять (0 Infiniti вверх/вниз)
//TODO Размеры и прокрутка элементов

// --------------------------------------------------------------------------------------------------------

//TODO Размеры и прокрутка окна
//? document.documentElement(это <html></html>).clientHeight/Width - ширина и высота окна с вычитом полосы прокрутки
//? window.innerHeight/innerWidth - ширина и высота окна (включает место занимаемое полосой прокрутки)
//? window.pageXOffset/pageYOffset - текущая прокрутка слева/сверху (только для чтения)
//? window.scrollBy(x,y) - прокручивает страницу относительно её текущего положения.
//? window.scrollTo(pageX,pageY) - прокручивает страницу чтобы левый-верхний угол видимой части страницы имел данные координаты относительно левого верхнего угла документа.
//? elem.scrollIntoView(top) - прокручивает страницу, чтобы elem оказался
//? top=true (по умолчанию), то страница будет прокручена, чтобы elem появился в верхней части окна. Верхний край элемента совмещён с верхней частью окна.
//? top=false, то страница будет прокручена, чтобы elem появился внизу. Нижний край элемента будет совмещён с нижним краем окна.
//? document.body.style.overflow = "hidden" - запретить прокрутку ('' - разрешить)
//TODO Размеры и прокрутка окна

// --------------------------------------------------------------------------------------------------------

//TODO Координаты относительно окна браузера
//! elem.getBoundingClientRect() - возвращает объект с координатами elem относительно окна браузера
//! - x/y координаты начала elem относительно окна
//! - width/height (ширина/высота) elem (могут быть отрицательными).
//! - top/bottom – Y-координата верхней/нижней границы elem.
//! - left/right – X-координата левой/правой границы elem.
//! document.elementFromPoint(x, y) - возвращает самый глубоко вложенный элемент в окне, находящийся по координатам (x, y), если x && y < 0 - null
//TODO Координаты относительно окна браузера

// --------------------------------------------------------------------------------------------------------

//TODO События
//* внутри обработчика события this ссылается на текущий элемент, на тот на котором висит этот обработчик
//* можно добавить обработчик как метод объекту элемента, название метота on + event, пример onclick
//* elem.addEventListener(событие, handler(event), {options}) - слушатель события, removeEventListener(event, handler, {options) - удаление обработчкиа
//* options - объект с параметрами.
//* event - объект события. .type - тип события, .clientX/Y - коорбинаты курсора в моент клика относительно окна браузера, .currentTarget - элемент на который привязанно событие
//* обработчиком может быть объект, тогда слушатель вызовет .handleEvent(event) у этоко объекта --> значит юзаем классы
//? -------------------------------------------------- Всплытие и Погружение (жизненый цикл событий) ------------------------------------------
//* жизненый цикл событий состоит из 3 стадий (фаз)
//* 1: погружение - от целевоо объекта (window в частности) событие идет в них по цепочке до целевого элемента (event.target)
//* 2: достижение цели (event.target)
//* 3: всплытие - от целевого элемента вверх по цепочке родителей попутно вызывая события
//* event.target - элемент на котором сработал обработчик события (при 'click' на него кликнули мышью), не путасть с event.currentTarget/this!!
//* event.stopPropagation() - останавливает всплытие событий дальше, но после обработки события на элементе на котором вызван
//* event.stopImmediatePropagation() - останавливает всплытие событий дальше, не обрабатывая события на текущем элементе
//* обработка событий по умолчанию происходит на всплытии, но с 3 аргументов слушателя {capture: true/false (по умолчанию false)} мы можем вызывать события при погружении
//? -------------------------------------------------- Всплытие и Погружение (жизненый цикл событий) ------------------------------------------
//* el.contains(el2) - вернет boolean значение, являеится ли el2 потомком el
//* el.closest('CSSSelector') - вернет ближайшего родителя(или сам el) соответствующего данному селектору или null
//TODO События

// --------------------------------------------------------------------------------------------------------

//TODO События по умолчанию
//? event.preventDefault() - отменяет действия браузера или return false (если on<событие>)
//? addEventListener(..,..,{pasive: true}) - сообщает браузеру что обработчик не собирается выполнять .preventDefault()
//? совойство event.defaultPrevented - установлено в true, если действие по умолчанию было предотвращено, и false, если нет.
//TODO События по умолчанию

// --------------------------------------------------------------------------------------------------------

//TODO Генерация пользовательских событий
//! new Event(type, {options}) - корневой класс для генерации событий, type - строка (событие), {options} - параметры(по умолчанию все установлены в false)
//! { bubbles: true/false - если true, тогда событие всплывает
//! cancelable: true/false - если true, тогда можно отменить действие по умолчанию (.preventDefault())
//! composed: true/false - если true, тогда событие будет вплывать за пределы ShadowDOM }
//! elem.dispatchEvent(event) - запуск события на элементе
//! event.isTrusted - true когда событие реальное, false когда сгенерированно
//! лучше сначала почитать какой класс стоит ипользовать для генерации того или иного события, т.к в них можно указать стандартные свойства для данного типа событий
//! new CustomEvent() - стоит использовать для генерации совершенно новых событий, т.к присутствует поле detail в которое можно информацию для передачи в событие
//! если вызвать event.preventDefault() то elem.dispatchEvent(event) вернет false сигнализируя что продолжать не нужно
//TODO Генерация пользовательских событий

// --------------------------------------------------------------------------------------------------------

//TODO Интерфейсные события
//?---------------------------------------- События Мыши --------------------------------------------------
//* mousedown/mouseup - Кнопка мыши нажата/отпущена над элементом.
//* mouseover/mouseout - Курсор мыши появляется над элементом и уходит с него (переход от родителя к потомку тоже вызывает их)
//* event.target – это элемент, на который перешел, event.relatedTarget – это элемент, с которого курсор ушел(для mouseout наоборот)
//* mousemove - Каждое движение мыши над элементом генерирует это событие.
//* contextmenu - Вызывается при попытке открытия контекстного меню, как правило, нажатием правой кнопки
//* click - Вызывается при mousedown , а затем mouseup над одним и тем же элементом, если использовалась левая кнопка мыши.
//* dblclick - Вызывается двойным кликом на элементе.
//* event.which - какая кнопка мыши нажата (1 - левая, 2 - средняя, 3 - правая)
//* event.shiftKey(shift)/altKey(Alt или Opt для Mac)/ctrlKey(Ctrl)/metaKey(Cmd для Mac) - true если были нажаты
//* Отменить выделение - отключить событие по умолчанию при mousedown
//* Отменить копирование - событие oncopy
//* Координаты относительно окна: clientX/clientY
//* Координаты относительно документа: pageX/pageY
//?---------------------------------------- Dragon Drop --------------------------------------------------
//* dragstart - встроеное браузером событие ДрагонДроп
//?---------------------------------------- Клавиатура ---------------------------------------------------
//* Событие keydown происходит при нажатии клавиши, а keyup – при отпускании.
//* event.code - буква/символ,возвращаемое значение "Key...", event.key - символ(регистрозависим), возвращаемое значение символ
//* Для событий, вызванных автоповтором, event.repeat равно true.
//TODO Интерфейсные события

// --------------------------------------------------------------------------------------------------------

//TODO Работа с формами
//? document.form[class/id] - сюда входят все формы (HTMLCollection), form.elements[class/id] - елементы формы
//? получив элемент мы может остучаться до его формы element.form
//? input.value/checked - получить значение, textarea.value - получить значение
//? select.options - получить коллекцию вложеных option
//? option.selected - выбрана ли обция (true/false)
//!--------------------------------------------------- focus/blur ------------------------------------------------
//? событие focus - вызывается в момент фокусировки на элементе, blur - в момент потери фокуса, эти события не всплывают
//? методы elem.focus() - устанавливают вокус на элементе, elem.blur() - снимают фокус с него
//? что бы добавить фокусировку любому элементу, атрибут tabindex = number(0 - без приоритера, -1 - только .focus()/blur())
//? события focusin(focus) и focusout(blur) - всплывают, можно использовать делегирование
//? текущий элемент с фокусом можно получить из document.activeElement
//!---------------------------------------- change, input, cut, copy, paste --------------------------------
//? change - срабатывает по окончанию изменения элемента
//? input - срабатывает каждый раз при изменении значения, event.preventDefault() не работает.
//? cut, copy, paste - эти события происходят при вырезании/копировании/вставке данных
//? event.clipboardData - чтение/запись в буфер обмена
//!---------------------------------------------------- submit(отправка формы) -----------------------------------
//? событие submit - происходит при отправке формы (при нажатии Enter или кнопку отправки формы)
//? form.submit() - отправка в ручную, не генерирует событие submit
//? что бы отменить отправку формы event.preventDefault()
//TODO Работа с формами

// --------------------------------------------------------------------------------------------------------

//TODO Загрузка документа и ресурсов
//! событие DOMContentLoaded - срабатывает когда загрузился только HTML(если на пути идет script, то он ждет пока он загрузится, блокирует DOM)
//! событие load на window - срабатывает когда загрузился HTML, CSS, img и другие ресурсы
//! событие unload на window - покидаем страницу, можно в фоне что-то запускать
//! navigator.sendBeacon(url, data) - посылает данные в фоне (при закрытии страницы), POST запрос, размер до 64кб, обычно испотльзется для отсылания статистики
//! событие beforeunload на window - когда покидаем страцу, если отменить его то всплывающее окно уточнит действия
//! document.readyState - показывает текущее состояние загрузки: loading - документ загружается, interactive - документ прочитан(DOMContentLoaded), complete - прочитан и все ресурсы загружены (window.onload)
//! атрибут defer(только для внешних скриптов) - скрипт загружается в фоновом режиме, не препятствуя собиранию DOM, до DOMContentLoaded, сохраняют последовательность сриптов
//! атрибут async - скрипт абсолютно независим, когда загрузится тогда и выполнится, никого не ждет и его никто не ждет
//! динамические скрипты, которые вставленые в HTML с помощью JS по умолчанию async
//! async и defer не блокируют загрузку DOM, в отличии от стандартного <script> без них
//! HTML элементы имеющие атрибут src имеют события load - успешная загрузка и error - что-то пошло не так
//TODO Загрузка документа и ресурсов

// --------------------------------------------------------------------------------------------------------

//TODO Событийный цикл
//* асинхронный код всегда выполняется после синхронного (SeTimeout, Promise.then.catch будут выполнены после синхронного кода)
//* https://coderoad.ru/25915634/%D0%A0%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B5%D0%B9-%D0%B8-%D0%BC%D0%B0%D0%BA%D1%80%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B5%D0%B9-%D0%B2-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B5-%D1%86%D0%B8%D0%BA%D0%BB%D0%B0-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9

//* При одном обходе цикла событий будет обработана ровно одна задача из очереди макрозадач (эта очередь просто называется очередью задач в спецификации WHATWG ). После завершения этой макрозадачи все доступные микрозадачи будут обработаны, а именно в рамках одного и того же цикла обхода. Пока эти микрозадачи обрабатываются, они могут ставить в очередь еще больше микрозадач, которые будут выполняться одна за другой, пока очередь микрозадач не будет исчерпана.

//* Каковы практические последствия этого?
//* Если микрозадача рекурсивно ставит в очередь другие микрозадачи, может потребоваться много времени, пока не будет обработана следующая макрозадача. Это означает, что вы можете получить заблокированный UI или какой-то завершенный ввод-вывод в вашем приложении.
//* Однако, по крайней мере, в отношении функции Node.js's process.nextTick (которая ставит в очередь микрозадачи ), существует встроенная защита от такой блокировки с помощью process.maxTickDepth. Это значение по умолчанию равно 1000, что сокращает дальнейшую обработку микрозадач после достижения этого предела, что позволяет обрабатывать следующую макрозадачу )
//* Так когда же использовать что?
//* В принципе, используйте микрозадачи , когда вам нужно делать что-то асинхронно синхронно (т. Е. Когда вы сказали бы, что выполните эту (микро -) задачу в самом ближайшем будущем ). В противном случае придерживайтесь макрозадач .
//* Примеры
//* макрозадачи: setTimeout , setInterval , setImmediate , requestAnimationFrame , ввод-вывод , UI
//* микрозадачи: process.nextTick , queueMicrotask , MutationObserver

//* что бы добавить макрозадачу используем SetTimeout(func) с нулевой задержкой
//* что бы добавить микрозадачу используйте queueMicrotask(func) или обработчики промисов
//* микрозадачи исполняются непрерывно одна за другой.
//* WebWorkers - для паралельного вычисления, со своим окружением
//TODO Событийный цикл
// --------------------------------------------------------------------------------------------------------

//TODO Фреймы и окна
//? window.open(url, name, params) - открытие нового окна, url - ссылка, name - если есть окно с таким именем то откроется в нем
//? params - строка параметров разделеная запятыми БЕЗ ПРОБЛЕОВ!
//? вызов open - возвращает ссылку на новое окно
//? окна имеют доступ к друг другу только если они с одного источника (совпадают домен, протокол и порт)
//? window.opener - ссылка из попапа на окно которое его открыло. Она равна null для всех окон, кроме попапов.
//? всплывающие окна блокируются браузером, если они вызов window.open произошел не в результате действия пользователя
//? window.close() - закрыть окно (только для попапов), window.closed = true - если окно закрыто
//!--------------------------------------------------------- <iframe></iframe> -----------------------------
//? iframe.contentWindow - ссылка на объект window внутри <iframe>
//? iframe.contentDocument – ссылка на объект document внутри <iframe>
//? если разные источники, только изменения location и iframe.contentWindow
//? window.frames - коллекция фреймов в окне
//!--------------------------------------------------------- обмен собщениями между конами ------------------
//? win.postMessage(data, targetOrigin), data - данные для отправки, targetOrigin - определяет источник для окна получателя
//? что бы получить сообжение нужно вызвать событие message
//TODO Фреймы и окна

// --------------------------------------------------------------------------------------------------------

//TODO Бинарыне данныйе и файлы
//!
//!
//!
//!
//!
//!
//!
//!
//!
//!
//!
//!
//TODO Бинарыне данныйе и файлы

// --------------------------------------------------------------------------------------------------------

//TODO Сетевые запросы
//* fetch(url, [{options}]) - сетевой запрос, url - адрес (ссылка), без options будет GET запрос, возвращает "Promise"
//* сначало приходит заголовок ответа, свойста ответа - status: HTTP статус, ok: true если status: 200-299
//* для чтения тела ответа используем методы .json() - декодирование в формате JSON, .text() - возвращает ответ как текст
//* прочитать тело ответа можно только одним из методов
//* Заголовки ответа - .headers(псевдо Map, методы работают)
//* Заголовки запроса - устанавливаются в {options} в поле headers
//!------------------------------------------------ FormData ------------------------------------------------------------
//* Параметры fetch - body: - тело запроса (JSON, FormData, Blob/BufferSourse и т.д), method: - HTTP метод ("POST")
//* FormData(форма) - класс для отправки форм(автоматически считывает данные формы) => body: FormData
//* Объекты FormData всегда отсылаются с заголовком Content-Type: form/multipart это позволяет отправлять файлы
//* методы FormData: append(name, value) - новое поле name: value || append(name, blob, filename) - добавляет поле по типу <input type='file'>
//* append - может создавать поля с одинаковыми именами
//* delete(name) - удаляет поле name | get(name) - получения значения поля | has(name) - true/false
//* set(name, value)/(name, blob, filename) - удаляет все существующие поля с данными именами и добавляет новое
//!------------------------------------------------ Отмена асинхроных задач ---------------------------------------------
//* let controller = AbortController() - класс для создания объекта отмены асинхронных задач
//* controller - объект отмены, controller.abort() - генерирует событие 'abort' на controller.signal, ontroller.signal.aborted становиться true
//* обработчик ставиться именно на этот объект
//* опцией в fetch(url, {signal: controller.signal}) - так fetch сам слушает событие при .abort() делает отмену генерируя throw AbortError
//* если повесить поля одного объекта для нескольких fetch, то отменяться сразу несколько запросов
//* отменяються не только запросы но и любыет асинхронные задачи
//!------------------------------------------------ CORS ----------------------------------------------------------------
//* https://learn.javascript.ru/fetch-crossorigin
//!------------------------------------------------ Fetch API -----------------------------------------------------------
//* https://learn.javascript.ru/fetch-api
//!------------------------------------------------ Объект URL ----------------------------------------------------------
//* new URL(url: strig, [base]) - класс для создания объекта URL, для использования с запросами fetch или XHR
//* url - полный адрес, или только только путь если указак base - базовый адрес
//* let url1 = new URL('https://javascript.info/profile/admin') - указан только url
//* let url2 = new URL('/profile/admin', 'https://javascript.info') - указан url как путь, и base как базовый url
//* эти два примера выдают на выходе одинаковый url адрес
//* объект URL дает доступ к компонентам url, для разбора его по частям - .protocol, host, path и тд
//* url.searchParams - объект для добавления параметров к Url, используя его методы для добавления и других операций автоматически кодирует и декодирует их
//!------------------------------------------------- XMLHttpRequest ------------------------------------------------------
//* https://learn.javascript.ru/xmlhttprequest
//!------------------------------------------------- WebSocket -----------------------------------------------------------
//* WebSocket(protocol) - клас для создания инстанса вебсокета, protocol - ws/wss как http/https, отправлять данные может и клиен и сервер
//* события WebSocket: open - соединение установлено, message - получены данные, error - ошибка, close - соединение закрыто
//* .send(data) - отправка данных, data - string/бинырные данные (при отправке любой формат), бинарные данные при получении ArrayBuffer/Blob, .bufferType - задаем формат приема бинырных данных (по умолчанию blob)
//* socket.bufferedAmount - хранит количество байт буферизованных данных на текущий момент, ожидающих отправки по сети
//* для закрытия соединения socket.close([code], [reason]) code - спец. код закрытия WS, reason - описание причины закрытия, .wasClean - число ли закрыто соединение, другая сторона получить эти данные в событии close
//* socket.readyState - состояние соединения 0 - CONNECTING, 1 - OPEN, 2 - CLOSING, 3 - CLOSE
//!-------------------------------------------------- SSE(Server Send Events) ---------------------------------------------
//* EventSource(url) - класс для работы SSE, данные посылает только сервер, data - только string, protocol - HTTP
//* поле открытия соединения, ответ - Content-Type: text/event-stream, status - 200
//* при получении данных генерируется событие message (event.data - данные)
//* поддерживает CORS, для отправки авторизационных данных withCredentials: true
//* если соединение закрыто, что бы открыть новое создаем новый instans, закрыть - .close()
//* автоматическое переподключение при потери соединения retry: ms - поле data От сервера с рекомендованым временем переподключения, readyStatу (проверка сотояния) - 0 - connecting, 1 - open, 2 - close
//* события: open - соединение открыто, message - получены данные (event.data), error - не удается установить соединение
//TODO Сетевые запросы

// --------------------------------------------------------------------------------------------------------

//TODO Хранение данных в браузере
//!------------------------------------------------- Coockie -------------------------------------------------------------
//? document.cookie - чтение куков. Строка формата ключ=значение разделенная ;
//? Запись в document.cookie обновит только упомянутые в ней куки, но при этом не затронет все остальные
//? encodeURIComponent() - встроенная функция для кодировки (лучше ее использовать), decodeURIComponent() - декодировка
//? после закрытия браузера куки удаляются - это session cookie, что бы такого не было установить cookie expires=toUTCString(дата удаления куке)
//? max-age=second - определяет срок действия cookie в секундах, алтернатива expires
//? кук secure - только HTTPS протокол
//? httpOnly - настройка cookie, если она стоит то из Js к cookie не достучаться
//!------------------------------------------------- LocalStorage, sessionStorage -----------------------------------------
//? хранилище привязано к источкину - домен/протокол/порт
//? setItem(key, value) – сохранить пару ключ/значение || getItem(key) – получить данные по ключу key.
//? removeItem(key) – удалить данные с ключом key || clear() – удалить всё ||key(index) – получить ключ на заданной позиции.
//? length – количество элементов в хранилище.
//? LocalStorage - один на все вкладки в рамках источника, не имеет срока (данные не удаляются поле перещагрузки браузера)
//? Не итерируется как обычный массив
//? ключи и занчение - только string или JSON, если другой тип то приводится к string
//? SessionStorage - существует только в рамках текущей вкладки
//? существуют после перезагрузки страницы, но не после открытия закрытия вкладки
//? Событие 'storage' - генерируется при записи в Local/SessionStorage но не в текущей вкладке
//? event - .key - ключ который обновился,cancelAnimationFrame(requestId) .oldValue - старое значение, .newValue - Новое значение, .url - url документа где произошло событие
//? .storageArea -  locas/session storage - где произошло обновление
//!------------------------------------------------ IndexedDB -------------------------------------------------------------
//? встроенаая база данных мощнее local/session storage
//?
//TODO Хранение данных в браузере

//------------------------------------------------------------------------------------------------------------------------------------------------------

//TODO Анимация
//! transitionend - событие завершения анимации, event.propertName - имя анимации, event.elapsedTimes - время которое заняла анимация
//! requestId = requestAnimationFrame(callback) - умная перерисовка браузером, cancelAnimationFrame(requestId) - для отмены
//TODO Анимация


