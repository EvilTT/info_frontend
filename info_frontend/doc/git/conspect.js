
//? HEAD - указывает на последний коммит в текущей ветке
//TODO Начало работы (init, clone)
//! git init [dirname] - инициализировать git в данной дирректории или создаст папку и инициализирует в ней гит
//! git clone [url] - клонирует удаленный репозиторий с текущую дирректорию   
//TODO Сохранение изменений (add, commit) 
//* git add [file, dirrectory] - проиндексировать(отметить измененный файл/файлы)
//! --> --all/"." - проиндексироват все файлы
//* git commit -m "" - добавить комит с комментарием
//! --> без -m откроется поле где нужно указать комментарий к комиту затем зарыть его
//! --> --amend [-m "коммент"] - локально: добавит к предыдущему коммиту проиндексированные файлы и предложит изменить сообщение комита если без -m. На удаленном репозитории: сначала все так же как и локально, после git push --force(-f) - заменит удаленно последний комит на последний локальный (такое поведение из-за изменения hash комита)

//TODO Взаимодействие с удаленным репозиторием (remote, fetch, pull, push)
//* git remote - выведет список подключения к другим репозиториям (ярлыки на них)
//! --> -v - выведет тот же список но с ссылками на репозитории 
//* git remote add [name] [url] - подключения к репозиторию по url по ярлыку Name(придумать самому)
//? При клонировании репозитория, автоматически создается git remote add на этот репозиторий с ярлыком origin 
//! --> rm [name] - удаления подключения к репозиторию по ярлыку 
//! --> rename <old-name> <new-name> - переименовать ярлык  
//* git fetch [ярлык]или/и[имя ветки] - загружает все из удаленного репозитория в локальный не измення его а создавая новую ветку
//? После fetch нужно либо git merge либо перейти на то что пришло 
//* git pull [ярлык] - загрузит изменения текущей ветки и смержит ее с текущей  
//! -->  --rebase - вместо merge использует rebase

//TODO Other (status, log)
//! git status - покажет статус вашего локального git репозитория
//! git log - выведет в консоль историю коммитов
//! --> --oneline - вернет Log все коммитов вида has - comment
//* git cherry-pick [hash] - скоприрует коммит по hash на ту теку на которой находимся 

// TODO Отмена действий (clean, revert, reset)
//* git clean - удалит все неотслеживаемые файлы (не отмеченые в git add), но не тронет файлы отмеченые в .gitignore
//! --> -n выполнит тестово git clean и выведит в консоль удаляемые файлы, но не удалит их 
//! --> -f или --force - нужно указать всегда, что бы git clean сработало
//! --> -d говорит что удалять надо так же и неостеживаемые каталоги(папки), комбинируя -dn, -df
//* git revert HEAD - создаст новый коммит с отменой изменений оставив отменяемый коммит в истории
//! --> --no-edit - не отроет редактор сообщения коммита
//* git reset [hash] - откта до коммита 
//! --> --soft - отменит git commit прерыдушего commit'a, то есть все изменения отсануться но не будут закомичены 
//! --> --mixed(default) - отменят git commit и git add предыдущего commit'a
//! --> --hard откатит до прерыдущего коммита (отменив се команды)
//! --> HEAD~number - откал на кол-во коммитов
//! --> HEAD - отмена git add 
//* git restore <filename> - вернет удаленный файл если он был в diff git

//TODO Ветки, коммиты (checkout, branch, stash, merge, rebase) 
//* git checkout [hash, branch_name] - переходит на указанную ветку/коммит
//! --> -b [name] - создает ветку и сразу же переходит на нее
//! --> -f --forece - перейдет на указаную ветку стерев незакомиченые изменения
//* git branch [name_branch] - создает ветку
//! --> -d [name_branch] - удаление указанной ветки 
//! --> -D [name_branch] - удаляет ветку принудительно  
//! --> -M [name_branch] - переименовывает ветку находясь на ней 
//* git stash - сделает локальное сохранение незакомиченных изменений 
//* git stash pop - вернуть незакомиченные изменения, там где они были сделаны 
//* git merge [name branch] - смержить (соединить) ветки, находясь на ветке куда мержить
//? Если последний commit ветки куда мы mergim является родителем той ветки которую мы мержим, то git merge передвинет указатель HEAD На последний commit этой ветки (без commit'a слияния) 
//? Если это не так то создается commit слияния, в котором смежжаться (с конфликтом или без последние коммиты с веток)
//* git rebase [name branch] - переместить ветку, находясь на ветке куда перемещать
//* git push origin --delete <branckName> - удалить ветку на удаленном репозитории

//TODO Тэги
//* git tag [nameTag] - на текущем коммите
//* git tag -a [nameTag] -m "message" - на текущем комите
//* git push [tagName] - запушить тэг
//* git push --tags  - Запушить все тэги
//* git tag - посмотреть тэги