//------------------------------------------------------------------------
//TODO --------------------------------- Redux -------------------------------
//!--------------------------------- Базовое понимание -------------------
//* component => action => store => middlewares <=> reducer => store => component
//* Redux оповещает компоненты об изменении store через React context (используя его под капотом)
//* dispatch action (действие) в store, store вызывает reducer c 2 параметрами: текущий state и action, далее если reducer объеденены через combineReducer то вызывается каждый reducer и результат объединяется в новый state
//* action = {объект} с указанием типа действия {type: "действие", payload: {Данные}}
//*    action тоже выносим и диспачим функцию которая создает action, actionCreator - функция создает action
//*    dispath(action) - вызывается из компонента для изменения satate
//*    reducer() = по типу действия (type: 'Действие') изменяет или не изменяет state
//*    в каждом reducer указывает initialState свой
//*    должен возвращать всегда новый state а не мутировать предыдущий
//*    combineReducer({key: reducer, ...}) - объединяет все reducer
//*    createStore(reducers, [initialState])
//* 3 принципа: состояние - единственный источник правды, состояние только для чтения, редусеры - чистые функции, store имутабелен

//TODO ------------------------------------ React-Redux class Component ----------------------
//* <Provider store={store}></Provider> оборачиваем все приложение в него, передает prop store - наш store
//* connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])(Component) - возвращает HOC подлюченный к store, в который мы оборачиваем компоненте.

//? mapStateToProps(state, [{ownProps}]) -> вызывается каждый раз когда состояние store изменилось, принимает текущий state. Может возвращать объект {} с props, который объединиться с props комопнента и будет доуступен через this.props.

//? mapDispatchToProps -> если в connect() не передавать ее, то она просто привяжет dispatch к props компонента, доступный через props.dispatch().
//?    Если передать объект (mapDispatchToProps = {}), то каждая функция будет воспринята как actionCreitor и этот объект будут объединен с props компонента, доступ через props.[key(ключ в объекте)], пример объекта {deleteComment: delete}, где delete - это actionCreitor. Доступ props.delete()
//?     Если передать функцию вида (mapDispatchToProps = (dispatch, [{ownProps}]) => {}) она должна возвращать объект, с привязанными actionCreator к dispatch.
//?       Так же можно использовать bindActionCreators(actionCreators, dispatch), где actionCreators объект с actionCreator, она возвращает объект с привязаными к dispatch actionCreator. import * as ActionsCreators from './actions' , импортируем все как объект и передаем его первым аргументом

//* ownProps - объект с props компонента оборачиваемого в connect

//? mergeProps -> функция принимающая stateProps(объект возвращенный и mapStateToProps), dispatchProps (объект возвращенный из mapDispatchToProps) и ownProps, возвращающая объект объединяющий все аргументы в один и передающий его в качестве props оборачиваемому комопненту

//? options - объект с параметрами

//!------------------------------------ Redux-Redux hooks -----------------------------
//* useDispatch() - возвращает функцию dispatch для дальнейшего ее вызова с action/sctionCreator
//* useSelector(state => state.[]., [shallowEqual]) - возвращает указанное вами поля состояния для его дальнейшего использования
//* useStore() - возвращает redux store

//TODO------------------------------------ Libraries ---------------------------------------
//!------------------------------------Redux thunk ----------------------------------------------
//* action возвращает функцию с 1 аргументом - dispatch, который можно вызвать когда угодно внутри этой функции, в которой мы и реализуем асинхронность
//* в конфигурацию store добавить middlewire - обработчики асинхронных действий, в redux-thunk - это thunk
//* applyMiddlewires(middlewires) - функция redux регистрирующая middlewires
//* возвращенную из actionCreator функцию redux обрабатывает как middleware и в ней можно использовать side-effect

//! --------------------------------------- Reselect ----------------------------------
//* с помощью этой библиотеки мы можем кэшировать selector(части store)
//* селектор пересчитываеться когда изменяются его входящие данные в ином случае, возвращается закешированный selector

//? createSelector(...selectors||[selectors], returnSelector, [{options}]) - возвращает селектор, который в дальнейшем мы можем использовать в mapStateToProps/useSelector. Возвращеный selector обычно(но не всегда) принимает state.
//* Принимает 1 или несколько входных селекторов (обычно это функции в которые приходит state и они достают его отдельные части, (state) => state.todos.cart и т.п)
//* Результат(ты) выполнения входных селекторов передаются в аргументы returnSelector который должен возвращать окончательный результат
//* по умолчанию размер кеша createSelector эдиница(1) но это можно изменить с помощью параметров
//* при передаче в созданный selectore других аргументов они будут попадать в каждую входную функцию тем же аргументом (по счету), что и входящий
//*
//*
//*

//!------------------------------------Redux-Saga-------------------------------------------------
//* библиотека для упрашения работы с асинхронным потоком в Redux, реализованаая с помощью генераторов

//? 3 основные концепции: worker - выполняет бизнес-логику (запрос/timeout/cash...), watcher - наблюдает (ждет определенного action) т запускает worker, effect - создают простые объекты с инструкциями которые выполняет redux-saga.

//* createSagaMiddlewares([{options}]) - создаем middleware для sag и помещаем в applyMiddlewares
//* затем методом .run(rootSaga) - запускаем sagi, rootSaga - должна быть генератором, метот должен быть вызван ТОЛЬКО после applyMiddlewares
//* options принимает 1 - context, который будет доступен внутри sag, 2- sagaMonitor, логгер для sag, 3 - onError, глобальный обработчик ошибок, 4 - effectMiddlewares - дополнительная обработка эффектов

//?---------------------------------------------Effects-------------------------------------------
//! эффекты делятся на блокирующие и неблокирующие. Блокирующие эффекты - приостанавливают выполнение sag пока не выполниться какое-либо действие (take, call). Неблокирующие эффекты - не преостанавливает выполнение sag, работают асинхронно (fork, spawn, put, cancel)
//! Перед каждым эффект использовать ключевое слово yield

//* take(actionType) - ожидает вызов экшена с actionType
//! takeEvery(actionType, worker) - ожидает action с actionType и вызывает worker, когда данный action вызовется
//* takeLatest (actionType, worker)) - отменяет предыдущую задачу sagi, если она все еще выполняется, вызывает только последнюю задачу (много кликов, обработает только последний)
//* takeLeading(actionType, worker)) - вызывает первую задачу и не будет вызывать остальные пока не завершытся предыдущая (много кликов, обработает 1)
//! put(action/actionCreator) - эммулирует dispatch(), вызывает его
//! call(func, args..) - вызывает func с args, для асинхронных действий ОБЯЗАТЕЛЬНО. (если переданя функция возвращает Promise, будет ждать пока он не вызовет resolve)
//! fork(func, args..) - вызывает func с args асинхронно, то есть запускает не блокирующие вызовы sag (не ждет пока Promise вызовет resolve), служит для управления параллелизмом. Задача вызванная в fork привязывается к корню родителя, все ошибки вызванные в детях всплывают до корня родителя и отменяют следующие sagi
//* spawn(func, args..) - аналог fork но saga вызванная таким образом не будет привязанна к родителю а будет вызванна в корне sagi, ошибки не будут отменять дальшейшие sagi и не будут всплывать
//* join(take) - повзоляет заблокирвать неблокирующий эффект, метод fork возвращает take, специальный объект для управления неблокирующим effect
//* select(store => {}) - возвращает Redux store
//! all([effect...]) - запускает паралельно все sagi и ждет пока они выполнятся, если все effect не блокирующие => all будет не блокирующим, если хоть одна saga блокирующая то и all будет блокирующая
//* delay(ms) - задержка, синхронный setTimeout
//* apply(this, method) - вызывает второй аругмент с контекстом переданным 1 аргументом

//! ----------------------------------Redux-persist----------------------------------------------------
//* служит для удобной связи redux-store и хранилища в браузере
//* сущности для хранения - storage(localStorage), storageSession(sessionStorage),
//* persistStore(store, [config, callback]) - возвращает персиситрованный store. callback - функция которая вызовется сразу после завершения регидрации. Config - объект с параметрами: manualPersist: true - что бы данные из кэша регидрировали не сразу после вызова persistStore, а при вызове .persist().
//* Так же есть методы .purge() - отчистить storage, .flush() - Записать все данные в storage. .pause() - преостановить регидрацию.
//* persistReducer(config, reducer) - возвращает персистированный reducer.
//* сonfig - объект с параметрами key: 'string', ключ для хранения. storage: storage - сущность для хранения (localStorage, sessionStorage и т.д), whitelist: ['имена ключей в store'] - будет кэшировать только те части store ключи которых в списке, blacklist: [] - работает ровно наоборот. stateReconciler: -то как начальное состояние будет объединяться с входящим. Можно персистировать как rooReduser так и отдельные reducer.
//* Согласование состояний - то как будет входящее состояние объединяться с начальным.
//* Для интеграции с React есть комопнент <PersistGate>App</PersistGate> в которое мы оборачиваем наше приложение. prop loading - то, что будет отображаться пока идет согласование состояний. prop persistor - наше персистированый store

//! ----------------------------------Redux-form-------------------------------------------------------
//* Работает по принципу redux cycle для форм.
//* import { reducer as formReducer } from 'redux-form' - в store {form: formReducer} - создает состояние для хранения данных формы.
//* reduxForm({form: 'data'})(Component) - с помощью этого HOC задается имя формы в state, для отправки формы на form вешаем omSubmit обработчик. Если обработчик приходит из проспс то вешаем его на компонент формы.
//* Fied - компонент интупа, prop type - тип инпута, для стилизации prop component - принимает функцию слилизации поля. renderField = ({ input, label, type, meta: { touched, error, warning }}) - вид функции, prop input распоковываем в input (...input). Валидация на уровне поля prop validate - принимает функцию/[функции] для валидации
//* Если нужно задать значения при инициализации actionCreator initialize(дата)
//* 3 вида валидации асинхронная, синхронная, во время сабмита. SubmissionError - class для общей ошибки для формы
//* валидация синхронная и асинхронная подключается в reduxForm HOC
//* Для валидации во время сабмита нужно изменить обработчик сабмита так, чтобы он возвращал промис:
//* Для синхронной валидации нужно вернуть объект с ошибкой
//* Асинхронная валидация принимает 2 параметра и dispatch, нужно выбросить объект с ошибкой throw {}

//! ----------------------------------Redux-Rematch----------------------------------------------------
//* Новое описание Redux
//* Для создания Store используется метод init(config) - возвращает store, config: name - имя store, models - объект с моделями
//* model - каждаямодель описывает определенную часть store, свои reducer и async logic. Model - Это объект с полями state - состояние, reducers - объект с reducers, effect: (dispatch) => ({async reducers})

//! --------------------------Redux DevTools------------------------------------------------------------
//* в createStore вторым параметром передает composeWithDevTools() а в нее applyMidlewares
