//!------------------------------------------------ React ------------------------------------------

//TODO Плюсы реакт, использование
//* VDOM(Reconcilation), JSx, декларативность, отчасти плюс что React это library, универсальность (сервер NextJS, мобилки React Native)
//* комюнити, facebook
//! декларатинвый стиль - описывает что делать, что должно получиться => по этому легче для восприятия  (map)
//! императивный стиль - описываем как делать, по этому сложнее(for)

//TODO Компоненты, Элементы, синтаксис JSx
//* Переменные, функции и т.д встраиваются в тэги JsX с помощью {} без $
//* JsX разметку можно использовать везде
//* Атрибуты тэгов пишуться с помощью camelCase, tabIndex = '0' или tabIndex = {user.index}
//* Если тег пуст, то его можно сразу же закрыть с помощью />  - <img href="sdasd"/>
//* Элементы - это то, из чего сделанный компоненты, это просые объекты, могут быть как HTML тэгами, так и собственными компонентами
//* Компоненты - это "коробки" для элементов которые возвращают JSx.

//TODO Рендеринг элементов
//! Client 
//* const root = createRoot(container, { onRecoverableError, identifierPrefix }) - создает корень (нужно для новых фич React 18)
//* onRecoverableError - необязательный обратный вызов, вызываемый, когда React автоматически восстанавливается после ошибок.
//* identifierPrefix - необязательный префикс, который React использует для идентификаторов, сгенерированных useId, нужен если в 1 документе больше 1 корня
//* root.unmount() - размонтирования корня
//* hydrateRoot(container, App, { onRecoverableError, identifierPrefix }) - метод для гидрации приложения отрендеренного на сервере 
//! Server
//* https://reactjs.org/docs/react-dom-server.html 

//TODO Props
//* компонента это - функция или класс с объектом параметров на входе, так называемым props
//* props - только для чтения, это параметры (аттрибуты тэга/компонента)
//* атрибуты пишуться в camelCase кроме data атрибутов, они data-attr так же как и в HTML
//* Компоненты называть всегда с заглавной буквы!
//* props.children - это контент между открывающим и закрывающим тегом компонента
//* props передаются от родителя к потомку
//* props в дочерние элементы можно передатавь ы помощью {...props}
//* Component.defaultProps = {} - значение пропсов по умолчанию

//TODO state
//* state - состояние, это объект параметров
//* начально состояние устанавливается в constructor
//* в конструктор передает props и также родительскому классу super(props)
//* что бы обновить состояние используем setState({новый state}) который бъединит текущее и новое состояние, при каждом обновлении состояния происходит рендер, изменения состояния при помощи setState асинхронное.
//* setState((state, props) => {}, [callback]) - чтобы изменять state основываясь на текущем state в setState передаем callback принимающий текущее state и props, вторым аргементом можно передать так же callback который выполниться сразу же после обновления state.
//* обновляется только то поле состояния, которое явно указанно
//* состояния можно передавать в виде пропсов дочерним компонентам

//TODO Жизненый цикл компонента(методы расположенны в порядке их вызова)
//?------------- Монтирование
//* constructor() - стандарт классов, всегда super(props) - прокидываем пропсы в родителя, определяем начальный state, только в constructor
//* static getDerivedStateFromProps(props, satate) - метод служащий для установки состояния в зависимости от props. Он не имеет доступа к инстансу компонента. Возвращать должен объект нового state либо null.
//! УСТАРЕЛ UNSAFE_componentWillMount() - можно обновлять state. Вызывается при SSR на сервере, по этому можно siide effect.
//* render() - возвращает JSx, создает Virtual DOM
//* обновление DOM
//* componentDidMount() - запускается 1 раз при монтированиие(первом создании компонента после render() в DOM). Можно вызывать setState() который вызовет дополнительный рендер
//?------------- Обновление
//! УСТАРЕЛ UNSAFE_componentWillReceiveProps(nextProps) - вызывается только когда изменяются props, перерисовывается родитель
//* static getDerivedStateFromProps(props, state) - при обновлении вызывается только при изменении пропсов, то есть ререндер родителя
//* shouldComponentUpdate(nextProps, nextState, nextContext) - предотвращает рендер на основании props и state, что бы предотвратить последующий цикл обновления - вернуть false, продолжить true(true по умолчанию). Вызывается при setState(), пропуская методы выше
//! УСТАРЕЛ UNSAFE_componentWillUpdate(nextProps, nextSatate) - вызывается только после shouldComponentUpdate
//? forceUpdate() - обновления в компонента начнутся с render(), нужен когда перерисовка зависит от чего то еще кроме state и props
//* render()
//* Обновление DOM
//* getSnapshotBeforeUpdate(prevProps, prevState) - выызвается перед фиксированием в DOM, возвращает напшоп или null
//* componentDidUpdate(prebProps, prevState, snapshot) - вызывается при каждом обновлении состояния компонента после render(), но перед обнолением DOM, если использовать setState() то оберунть его в усливие что бы не был бесконечный цикл рендера
//?------------- Размонтирование
//* componentWillUnmount() - происходит 1 раз перед размонтированием(удалением) компонента, в нем нужно нужно убрать все что устанавливал componentDidMount() для оптимизации. setState() вызывать нет смысла т.к после удаления компнента не происходит его рендер
//?---------------- Предохранители (обработчики ошибок в реакт компонентах)
//* когда происходит ошибка в компонете и ее ничто не отловило, React размонтирует все дерево компонентов из DOM
//* Предохранители перехватывают лшибки только в дочерних компонентах, в сами себе они ошибки не словят, асинхроноость,
//* static getDerivedStateFromError(error) - получает объект ошибки, возвращать должен новый state исходя из обновления которого мы показыаем запасной UI
//* componentDidCatch(error, info) - вызывается в момент монтирования, используется для логирования. error - объект ошибки, info - объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка

//TODO Обработка событий

//* события в реакт именуются в camelCase и передается функция обработчик
//* что бы словить события на всплытии on + Имя
//* что бы словить обытия на погружении on + Имя + [Capture]
//* отменить события по умолчанию только preventDefaut()
//* обработчик события передается в значение аттрибута(события) 3 способа
//! for class component 
//* 1 - явная привязка контекста к обработчику, использовать .bind(), делается в constructor
//* 2 - использовать new syntaxt methodObrabotchick = () => {}
//* 3 - передавать callback с вызовом обработчика onClick = {() => this.method()}
//* объект события (event) - это синтетическое React событие
//* что бы передать свой аргумент обработчику либо {(event) => this.method(param, event)} либо {this.method.bind(this, param)} - а событие будет передано как 2 аргумент

//TODO Условный рендеринг

//* рендерить(возвращать JSx) в зависимотси от условий. if/else либо тернарник условие ? true: false.
//* Что бы убрать компонент уже отрендереный нужно вернуть null, но жизенный цикл все ранво сработает

//TODO Списки и ключи

//* Список - это массив элементов. Если его встроить в JSx то React отобразит массив как список элементов
//* key - обязательный атрибут элемента списка, это должна быть уникальная String в контексте данного списка. С помощью нее React определяет какие элементы изменились и их нужно рендерить
//* key нужно определять непосредственно внутри массива
//* С помощью key, React паралельно итерируется по элементся ищя совпадения ключей, далее он сравнивает сами элементы. Не стоит использовать в качестве ключей в масиивах index. Т.к при добавлении в начало массива элемента он будет переиндексирован и все лючи обновятся, что скажется на производительности. Без указания key реакт будет последовательн обновлять все елементы в списке

//TODO Формы

//* Что бы управлять полями формы используются Управляемые компоненты. При каждом изменении в поле мы обновляемstate.value из Value поля и также value поля это state.value. То есть мы управляем состоянием поля в компоненте.
//* Если установить value null тогда значение поля нельзя изменить
//* Что бы обрабатывать таким образом множество полей можно изпользовать аттрибут name и type события

//TODO Подъем состояния

//* Поднимать состояния до ближайшего родителя и сделать дочерние компоненты управляемыми от этого состояния

//TODO Разделение кода

//* Использовать динамический импорт - import('./путь до файла').then(file => file.[то что хотите использовать, импортирует все export как объект])
//* const Component = React.lazy(() => динамический импорт) (ленивые компоненты) - эта функция загрузит необходимый банд, только при первом рендере компонента (компонент должен експортироваться только export default)
//* Ленивые компоненты должны быть обернуты в компонент <Suspense fallback={element}> - он позволяет показать запасное содержимое при загрузке (import). fallback принимает любой элемент который мы хотим показывать пока загружается ленивый компонент
//* Если всесте с Suspense использовать useTransition то можно можно добиться отложенного показа изменений, подробнее https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md

//TODO Контекст

//* Нужен для передачи данных через дерево компонентов без промежуточных props
//* Context = React.createContext(defaultValue) - создает объект Context с значением по умолчанию (defaultValue), которое используется ТОЛЬКО тогда, когда нет подходящего Provider.
//* <Context.Provider value={/* некоторое значение */}> - все дочерние компоненты будут использовать этот контекст. value - значение контекста. Provider может быть вложенным и переопределять друг друга. Все потребители, тек то подписан на данных context, будут повторно рендериться при изменении value. Если в value передавать объект, то потомки ьудут перерендериваться при каждом рендере родителя Provider, т.к value сравниваются по ссылкам. Что бы этого избежать помещать в value объект передаем не value = {{..}}, а value = {obj} то есть ссылку на него
//! static contextType/Class.contextType = Context(созданный с помощью createContext()) позоляет в classComponents использовать this.context
//* Что бы изменить контекст, либо меняем сам контекс(переданый в createContext) либо добавляем ненего метод меняющий его
//* <Context.Consumer>{value => /* отрендерить что-то, используя значение контекста */} </Context.Consumer> дочерний компонент это функция возвращающая компонент. value = Provider/defaultValue.
//* useContext(Context) аналогичен выражению "static contextType/class.contextType = MyContext"

//TODO Рефы и DOM
//* classComponent в constructor createRef()
//* ref это объект сохраняющий свое состояние между рендерами
//* прикрепив к NODE - ссылка на нее, к classComponents - на инстанс класса(можно вызывать его методы)
//* внутри FC можно createRef() если он будет ссылаться на DOM NODE или classComponents
//* можно передавать рефы как props дочерним компонентам, но не рекомендуется
//* callback ref это функции вида (el) => {} - el это то к чему будет прикреплен ref, нет поля current, тоже можно передавать как props
//! findDOMNode(component) - вернет DOM елемент, работает только на смонтированном компоненте, не работает с FC, не работает в React.StricktMode
//! рефы в стархы версиях это строка this.ref.string - удалены
//* forwardRef((props, ref) =>) - позволяет взять ref из propa ref компонета и перенаправить дочерним елементам/компонентам

//TODO Фрагменты
//* React.Fragment (<></>) - при рендере они просто убираются и используются в качестве контейнеа в компоннте ля дочерних элементов. Поддерживают key (только React.Fragment) есл использовать как список элементов.

//TODO HOC (Hight Ordered COmponent) Компоненты высшего порядка
//* HOC - это функции которые принимают компонент и возвращают новый компонент
//* Не изменяя входящий компонент

//TODO Порталы
//* ReactDOM.createPortal(chield, container) - этот метот рендерит chield (любой React элемент который может быть отрендерен) в container (DOMNode, вне текущей иерархии)
//* События всплывают как и обычно, т.к сам портал находится в иерархии React

//TODO Магия React (Reconcilation (согласование), Fiber, Конкурентный рендеринг, Batching)
//!----------------------------------------->> Reconcilation (Согласование)
//* Механизм (алгоритм) сравнения vDOM с DOM и его обновление
//* Два основных принципа, 1 - разные элементы порождают разные деревья, с помощью key пользователь указвает какие дочерние елементы остаются стабильными.
//* React сравнивает элементы, если они изменилиь он размонтирует все дочернее дерево. Он сравнивает аттрибуты и изменяет только изменившиеся значения.
//? После он отдает в DOM только, то что изменилось, там это превращается в нативные DOM операции. Происходит их преоритезация и они выполняются.
//!----------------------------------------->> Fiber (Согласование)
//* React fiber - алгоритм приоретизации этих операций, разбиения их на фреймы, отменять эти операции, переиспользовать их, что позволяет добиться 60 FPS.
//* React fiber - в некотором роде реализация стека для React компонентов.
//!----------------------------------------->> Конкурентный рендеринг
//* 
//!----------------------------------------->> Batching (автоматическое пакетирование)
//* React 17 - реакт под капотом пакетирует (группирует) только обновлений состояния в обработчиках событий
//* React 18 - автоматически пакетирует (группирует) обновления состояния в setTimeout, Promise, обработчиках событий и т.п. Что бы отменить это поведение, нужно обернуть фунцию обновления состояния в flushSync().

//TODO Transition (переходы) 
//* В React появилась концепция разграничения "срочных" и "не срочных" обновлений, срочные обновления - нажатия кнопки, ввод в инпут и т.д, не срочные - отображения сортировки по фильтру, отображения запроса по вводимым данным и т.п. "Не срочные" обновления React может прерывать для выполнения "Срочных".
//* [isPending, startTransition] = useTransition() - если обернуть обновления состояния в startTransition то React поймет, что это "не срочное" обновление и может прервать его для выполнения "срочного". Прерваные обновления отбрасываются и выполняются только последние. isPending: boolean показывает когда переход активен. 
//! for class component
//* startTransition() - аналог useTransition для classComponent

//TODO Render, Babel
//* метод render с помощью babel превращает JSx в вызовы createElement(), то есть транспилирует JSx в createElement, по сути JSx это удобная абстракция.
//! По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. Всё преобразуется в строчки, перед тем как быть отрендеренным. Это помогает предотвращать XSS атаки.

//TODO Рендер-пропсы (render-props)
//* это когда передаваемый props (или не один) это функции которые возвращают компоненты/элементы. То есть компонент в который передается ренер-пропс написан и не меняет своей логики, а лишь рендерит разный UI в зависимости и рендер-пропса который ему передали

//TODO PropTypes
//* что бы использовать npm prop-types
//* Component.propTypes = {prop: PropTypes.type} - типизация пропсов
//* .isRequared - обязательное поле, если его не будет выбросит исключение
//* .shape{} - объект с определеной структурой
//* js типы - .array, .bool, .func, .number, .object, .string, .symbol
//* .element - React element
//* .onceOf([..]) - ограничение конкретными значениями,
//* .arayOf(PropTypes.type) - массив объектов конкретного типа
//* .objectOf(PropTypes.type) - объект со свойствами конкретного типа
//* .any - обязательное значение любого типа
//*

//TODO React API
//* React.PureComponent - реализует shouldComponentUpdate под капотом, он сравнивает текущие и предыдущие пропсы и состоянии и если они не изменились отменит дальнейший рендер

//* React.memo(Component, isEqual()) - предназанчен для оптимизации производительности. Если комопнент рендерит одно и тоже при неизменяющихся пропсах то применяем. Вторым параметром можно передать callback(prevProps, nextProps) - возвращает true, если nextProps рендерит тот же результат что и prevProps, иначе возвращает false

//TODO -----------------------------------------Хуки------------------------------------

//? Правила использования хуков
//* Хуки следует вызывать только на верхнем уровне. Не вызывайте хуки внутри циклов, условий или вложенных функций.
//* Хуки вызываются либо из FC либо из кастомных хуков!
//* React полагается на прпялрк вызова хуков и гарантирует их корректную работу только при неизменном порядке вызова хуков при каждом рендере
//* Хуки позволяют эммулировать поведение и методы жизненного цикла class Components в FC, так же хуки работают лучше, т.к создать функцию проще чем создать instance класса.

//! useImperativeHandle(ref, () => (){}, [зависимости(как у useState, useEffect И т.д)]) - настраивает значение экземпляра, возвращаемого объекта. Т.к при ref к FC, мы не получаем доступ к инстансу(его нет), этот хук решает эту проблему. ref(prop) достаем с помощью forwardRef.

//* useState(value/callback), хук для установки внутреннего state. Возвращает state и функцию для его обновления в виде кортежа из 2 элементов. Если новый state зависит от предыдущего передаем в setState callback, в который аргументом передается текущее состояние, которое можно модифицировать. Для ленивой установки начального состояния в useState можно передать функцию которая будет возвращать состояние, React вызовет ее 1 раз, для установки начального состояния.

//? useEffect(callback, [zavisimosty]) - выполняет callback каждый раз если зависимостей нет. Что бы выполнить при монтировании, зависимости оставляем пустыми []. Если добавить зависимости, то при их изменении выполниться callback. Что бы выполнить при размонтировании, нужно из callback вернуть другой callback, который и выполниться при размонтировании компонента. useEffect Не альтернатива componentDidMount. Он выполняется после render() -> монтирование в дом. А componentDidMount выполняется после render вызывая последующий render.

//* useRef() - возвращает объект {current: ...} который не будет изменяться после каждого рендера или демонтитровании компонента, если поместить в аттрибут ref любого элемента то через ref.current вернет его DOM-node.
//* можно использовать для хранения других иммутабельных данных, просто в объеки созданый с помощью useRef() по ключу current записиваем эти данные

//? useContext(MyContext) аналогичен выражению "static contextType = MyContext" в классе, либо компоненту <MyContext.Consumer>, возвращает текущий контекст

//* useMemo(callback(a,b), [a, b]) - мемоизирует (кеширует) результат переданной функции, и пересчитывает его только при изменении параметров зависимостей, если он не указан то будет вычисляться каждый рендер. Запускается во время рендеринга (побочные эффекты тут писать нельзя).

//* useCallback(() => func(a, b), [a,b]) - возвращает мемоизированный колбек. При каждом рендере компонента все функции объявленые в нем пересоздаются. Что бы этого не было и нужен этот Хук. НО тут работает замыкание - функция помнит те данные которые были на момент ее создания.

//? [state, dispatch]=useReduser(reducer, initialState, [init]) - хук для управления состоянием с боллее сложной логикой. reducer = (state, action) => как в Redux. initialState = начальное состояние, init = функция которая должна вернуть состояние, используется при начальном рендеринге, для установки состояния динамически

//? useLayouteEffect() - API как и у useEffect, синхронно обновляет DOM, как componentDidMount/Update

//TODO-----------------------------------------React Router v6---------------------
//* <BrowserRouter> - корневой компонент. Им нужно обернуть корневой компонент
//* <Route/> - в нем указывается загружаемый (который будет отрендерен) компонент. Параметры: path='путь', должен совпадать с to того Link который указывает сюда. element={<Component/>} - то, какой компонент будет отрендерен. Параметры в path передаюся path='/root:param'
//* path с помощью RegExp компилируется в объект match. params - параметры из path
//* <Routes/> - оборачивам в него Route
//* <Link> - модифицированные ссылки (<a/>). Параметры: to='путь' - по какому адресу нужно загурузить компонент, должен совпадать с path желаемого <Route>
//* {params} = useParams() - возвращает объект параметров указанных в <Route path='/page/:id/params'/>
//* useLocation() - возвращает объект с путями
//* const navigate = useNavigate() - возвращает функцию навигации. navigate(1) - перейдет по истории вперед, navigate(-1) перейдет по истории назад, navigate('path', {options}) - перейдет по данному пути. Options: replace: true/false - если true не сохранит в историю наигации, false сохранит (default).
//* <Navigate to='путь куда перейти' replace - что бы не сохранялось в историю> - для редиректа, устанавливается в поле element Route

//TODO-----------------------------------------Styled-components---------------------
//? npm пакет styledcomponent, все префиксы добавляются автоматически
//? что бы использовать import style from "..."
//? const StyleButton = style.[HTMLNode]`style` , StyleButton - это компонент
//? `color: ${props => props...}` - установка стилей в зависимости от пропсов. Например color: ${spops => props.color || 'red'} - если нет пропса ставим цвет или defaultProps
//? глобальные стили import createGlobalStyle, пишем стили и помешаем этот компонент в любое место они применятся, но лучше помещать в корневой компонент
//? для псевдоэлементов ::pseudo{style}
//? для группировки свойст от props `${props => props.isFocus && css `style`}` import {css} для вложенных шаблонных литералов
//? для расширения уже существующих StyledComponents const newComponent = styled(Component)`style`. Component это та компонента которую мы расширяем и получаем в итогу новую
//? Для анимации импортируем keyframes. const animate = keyframes `anim` и переменную с анимацией используем как ее имя
//? Для указания props по умолчанию (дефолтных) используем style.[HTMLNode].attrs(props => ({и тут указываем их}))